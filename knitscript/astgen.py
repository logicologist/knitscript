from functools import singledispatch
from operator import attrgetter
from typing import Collection, Union

from knitscript.astnodes import Block, Call, Document, ExpandingStitchRepeat, \
    FixedBlockRepeat, FixedStitchRepeat, Get, NaturalLit, Node, PatternDef, \
    Pattern, Row, RowRepeat, Side, StitchLit, Using
from knitscript.parser.KnitScriptParser import KnitScriptParser, \
    ParserRuleContext
from knitscript.stitch import Stitch


@singledispatch
def build_ast(ctx: ParserRuleContext) -> Node:
    """
    Builds an AST from a parse tree generated by ANTLR.

    :param ctx: a parse tree context node
    :return: the AST corresponding to the parse tree
    """
    raise TypeError(f"unsupported parser context {type(ctx).__name__}")


@build_ast.register
def _(document: KnitScriptParser.DocumentContext) -> Node:
    return Document(map(build_ast, document.usings),
                    map(build_ast, document.patterns))


@build_ast.register
def _(using: KnitScriptParser.UsingStmtContext) -> Node:
    return Using(map(lambda name: name.text, using.patternNames),
                 using.filename.text)


@build_ast.register
def _(pattern: KnitScriptParser.PatternDefContext) -> Node:
    params = (map(attrgetter("text"), pattern.paramList().params)
              if pattern.paramList()
              else [])
    return PatternDef(pattern.ID().getText(),
                      Pattern(map(build_ast, pattern.items), params))


@build_ast.register
def _(item: KnitScriptParser.ItemContext) -> Node:
    return build_ast(item.row() or item.block() or item.rowRepeat())


@build_ast.register
def _(block: KnitScriptParser.BlockContext) -> Node:
    return Block(map(build_ast, block.patternList().patterns))


@build_ast.register
def _(repeat: KnitScriptParser.PatternRepeatContext) -> Node:
    return build_ast(repeat.fixedPatternRepeat() or repeat.call())


@build_ast.register
def _(repeat: KnitScriptParser.FixedPatternRepeatContext) -> Node:
    return FixedBlockRepeat(
        Block([build_ast(repeat.pattern)] if repeat.pattern is not None
              else map(build_ast, repeat.patternList().patterns)),
        build_ast(repeat.times)
    )


@build_ast.register
def _(call: KnitScriptParser.CallContext) -> Node:
    return Call(
        Get(call.ID().getText()),
        map(build_ast, call.argList().args) if call.argList() else []
    )


@build_ast.register
def _(repeat: KnitScriptParser.RowRepeatContext) -> Node:
    return RowRepeat(map(build_ast, repeat.items), build_ast(repeat.times))


@build_ast.register
def _(row: KnitScriptParser.RowContext) -> Node:
    return Row(
        map(build_ast,
            row.stitchList().stitches if row.stitchList() is not None else ()),
        Side(row.side().getText()) if row.side() is not None else None
    )


@build_ast.register
def _(repeat: KnitScriptParser.StitchRepeatContext) -> Node:
    return build_ast(repeat.fixedStitchRepeat() or
                     repeat.expandingStitchRepeat() or
                     repeat.stitch())


@build_ast.register
def _(fixed: KnitScriptParser.FixedStitchRepeatContext) -> Node:
    return FixedStitchRepeat(map(build_ast, _stitches(fixed)),
                             build_ast(fixed.times))


@build_ast.register
def _(expanding: KnitScriptParser.ExpandingStitchRepeatContext) -> Node:
    return ExpandingStitchRepeat(
        map(build_ast, _stitches(expanding)),
        build_ast(expanding.toLast) if expanding.toLast else NaturalLit(0)
    )


@build_ast.register
def _(stitch: KnitScriptParser.StitchContext) -> Node:
    return StitchLit(Stitch.from_symbol(stitch.ID().getText()))


@build_ast.register
def _(expr: KnitScriptParser.ExprContext) -> Node:
    return build_ast(expr.call() or expr.variable() or expr.natural())


@build_ast.register
def _(variable: KnitScriptParser.VariableContext) -> Node:
    return Get(variable.ID().getText())


@build_ast.register
def _(natural: KnitScriptParser.NaturalContext) -> Node:
    return NaturalLit(int(natural.getText()))


def _stitches(ctx: Union[KnitScriptParser.FixedStitchRepeatContext,
                         KnitScriptParser.ExpandingStitchRepeatContext]) \
        -> Collection[ParserRuleContext]:
    return [ctx.stitch()] if ctx.stitch() else ctx.stitchList().stitches
