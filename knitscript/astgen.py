from functools import singledispatch
from operator import attrgetter
from typing import Collection, Union

from knitscript.astnodes import BlockExpr, CallExpr, Document, \
    ExpandingStitchRepeatExpr, FixedStitchRepeatExpr, GetExpr, NaturalLit, \
    Node, PatternDef, PatternExpr, RowExpr, StitchLit
from knitscript.parser.KnitScriptParser import KnitScriptParser, \
    ParserRuleContext
from knitscript.stitch import Stitch


@singledispatch
def build_ast(ctx: ParserRuleContext) -> Node:
    """
    Builds an AST from a parse tree generated by ANTLR.

    :param ctx: a parse tree context node
    :return: the AST corresponding to the parse tree
    """
    raise TypeError(f"unsupported parser context {type(ctx).__name__}")


@build_ast.register
def _(document: KnitScriptParser.DocumentContext) -> Node:
    return Document(map(build_ast, document.patterns))


@build_ast.register
def _(pattern: KnitScriptParser.PatternDefContext) -> Node:
    params = (map(attrgetter("text"), pattern.paramList().params)
              if pattern.paramList()
              else [])
    return PatternDef(pattern.ID().getText(),
                      PatternExpr(map(build_ast, pattern.lines), params))


@build_ast.register
def _(line: KnitScriptParser.LineContext) -> Node:
    return build_ast(line.row() or line.block())


@build_ast.register
def _(block: KnitScriptParser.BlockContext) -> Node:
    return BlockExpr(map(build_ast, block.calls))


@build_ast.register
def _(call: KnitScriptParser.CallContext) -> Node:
    return CallExpr(
        GetExpr(call.ID().getText()),
        map(build_ast, call.argList().args) if call.argList() else []
    )


@build_ast.register
def _(row: KnitScriptParser.RowContext) -> Node:
    return RowExpr(map(build_ast, row.stitchList().stitches))


@build_ast.register
def _(repeat: KnitScriptParser.StitchRepeatContext) -> Node:
    return build_ast(repeat.fixedStitchRepeat() or
                     repeat.expandingStitchRepeat() or
                     repeat.stitch())


@build_ast.register
def _(fixed: KnitScriptParser.FixedStitchRepeatContext) -> Node:
    return FixedStitchRepeatExpr(map(build_ast, _stitches(fixed)),
                                 build_ast(fixed.count))


@build_ast.register
def _(expanding: KnitScriptParser.ExpandingStitchRepeatContext) -> Node:
    return ExpandingStitchRepeatExpr(
        map(build_ast, _stitches(expanding)),
        build_ast(expanding.toLast) if expanding.toLast else NaturalLit(0)
    )


@build_ast.register
def _(stitch: KnitScriptParser.StitchContext) -> Node:
    return StitchLit(Stitch.from_symbol(stitch.ID().getText()))


@build_ast.register
def _(expr: KnitScriptParser.ExprContext) -> Node:
    return build_ast(expr.variable() or expr.natural())


@build_ast.register
def _(variable: KnitScriptParser.VariableContext) -> Node:
    return GetExpr(variable.ID().getText())


@build_ast.register
def _(natural: KnitScriptParser.NaturalContext) -> Node:
    return NaturalLit(int(natural.getText()))


def _stitches(ctx: Union[KnitScriptParser.FixedStitchRepeatContext,
                         KnitScriptParser.ExpandingStitchRepeatContext]) \
        -> Collection[ParserRuleContext]:
    return [ctx.stitch()] if ctx.stitch() else ctx.stitchList().stitches
