from functools import singledispatch
from operator import attrgetter
from typing import Collection, Union

from antlr4 import ParserRuleContext, Token

from knitscript.astnodes import Block, Call, Document, ExpandingStitchRepeat, \
    FixedBlockRepeat, FixedStitchRepeat, Get, NaturalLit, Node, PatternDef, \
    Pattern, Row, RowRepeat, Side, Source, StitchLit, StringLit, Using
from knitscript.parser.KnitScriptParser import KnitScriptParser
from knitscript.stitch import Stitch


@singledispatch
def build_ast(ctx: ParserRuleContext) -> Node:
    """
    Builds an AST from a parse tree generated by ANTLR.

    :param ctx: a parse tree context node
    :return: the AST corresponding to the parse tree
    """
    raise TypeError(f"unsupported parser context {type(ctx).__name__}")


@build_ast.register
def _(document: KnitScriptParser.DocumentContext) -> Node:
    return Document(stmts=list(map(build_ast, document.stmts)),
                    sources=[_get_source(document.start)])


@build_ast.register
def _(stmt: KnitScriptParser.StmtContext) -> Node:
    return build_ast(stmt.using() or stmt.patternDef() or stmt.call())


@build_ast.register
def _(using: KnitScriptParser.UsingContext) -> Node:
    return Using(names=list(map(lambda name: name.text, using.names)),
                 module=using.module.text,
                 sources=[_get_source(using.start)])


@build_ast.register
def _(pattern: KnitScriptParser.PatternDefContext) -> Node:
    params = (list(map(attrgetter("text"), pattern.paramList().params))
              if pattern.paramList()
              else [])
    return PatternDef(
        name=pattern.ID().getText(),
        pattern=Pattern(rows=list(map(build_ast, pattern.items)),
                        params=params, env=None,
                        consumes=None, produces=None,
                        sources=[_get_source(pattern.start)]),
        sources=[_get_source(pattern.start)]
    )


@build_ast.register
def _(item: KnitScriptParser.ItemContext) -> Node:
    return build_ast(item.row() or item.block() or item.rowRepeat())


@build_ast.register
def _(block: KnitScriptParser.BlockContext) -> Node:
    return Block(patterns=list(map(build_ast, block.patternList().patterns)),
                 consumes=None, produces=None,
                 sources=[_get_source(block.start)])


@build_ast.register
def _(repeat: KnitScriptParser.PatternRepeatContext) -> Node:
    return build_ast(repeat.fixedPatternRepeat() or repeat.call())


@build_ast.register
def _(repeat: KnitScriptParser.FixedPatternRepeatContext) -> Node:
    return FixedBlockRepeat(
        block=Block(
            patterns=(
                [build_ast(repeat.pattern)]
                if repeat.pattern is not None
                else list(map(build_ast, repeat.patternList().patterns))
            ),
            consumes=None, produces=None,
            sources=[_get_source(repeat.start)]
        ),
        times=build_ast(repeat.times),
        consumes=None, produces=None,
        sources=[_get_source(repeat.start)]
    )


@build_ast.register
def _(call: KnitScriptParser.CallContext) -> Node:
    return Call(target=Get(name=call.ID().getText(),
                           sources=[_get_source(call.start)]),
                args=list(map(build_ast, call.args) if call.args else []),
                sources=[_get_source(call.start)])


@build_ast.register
def _(repeat: KnitScriptParser.RowRepeatContext) -> Node:
    return RowRepeat(rows=list(map(build_ast, repeat.items)),
                     times=build_ast(repeat.times),
                     consumes=None, produces=None,
                     sources=[_get_source(repeat.start)])


@build_ast.register
def _(row: KnitScriptParser.RowContext) -> Node:
    return Row(
        stitches=list(map(build_ast, (row.stitchList().stitches
                                      if row.stitchList() is not None
                                      else []))),
        side=Side(row.side().getText()) if row.side() is not None else None,
        consumes=None, produces=None,
        sources=[_get_source(row.start)]
    )


@build_ast.register
def _(repeat: KnitScriptParser.StitchRepeatContext) -> Node:
    return build_ast(repeat.fixedStitchRepeat() or
                     repeat.expandingStitchRepeat() or
                     repeat.stitch())


@build_ast.register
def _(fixed: KnitScriptParser.FixedStitchRepeatContext) -> Node:
    return FixedStitchRepeat(
        stitches=list(map(build_ast, _get_stitches(fixed))),
        times=build_ast(fixed.times),
        consumes=None, produces=None,
        sources=[_get_source(fixed.start)]
    )


@build_ast.register
def _(expanding: KnitScriptParser.ExpandingStitchRepeatContext) -> Node:
    return ExpandingStitchRepeat(
        stitches=list(map(build_ast, _get_stitches(expanding))),
        to_last=(build_ast(expanding.toLast)
                 if expanding.toLast
                 else NaturalLit.of(0)),
        consumes=None, produces=None,
        sources=[_get_source(expanding.start)]
    )


@build_ast.register
def _(stitch: KnitScriptParser.StitchContext) -> Node:
    value = Stitch.from_symbol(stitch.ID().getText())
    return StitchLit(value=value,
                     consumes=value.consumes, produces=value.produces,
                     sources=[_get_source(stitch.start)])


@build_ast.register
def _(expr: KnitScriptParser.ExprContext) -> Node:
    return build_ast(expr.call() or
                     expr.variable() or
                     expr.natural() or
                     expr.string())


@build_ast.register
def _(variable: KnitScriptParser.VariableContext) -> Node:
    return Get(name=variable.ID().getText(),
               sources=[_get_source(variable.start)])


@build_ast.register
def _(natural: KnitScriptParser.NaturalContext) -> Node:
    return NaturalLit(value=int(natural.getText()),
                      sources=[_get_source(natural.start)])


@build_ast.register
def _(string: KnitScriptParser.StringContext) -> Node:
    return StringLit(value=string.getText()[1:-1],
                     sources=[_get_source(string.start)])


def _get_stitches(ctx: Union[KnitScriptParser.FixedStitchRepeatContext,
                             KnitScriptParser.ExpandingStitchRepeatContext]) \
        -> Collection[ParserRuleContext]:
    return [ctx.stitch()] if ctx.stitch() else ctx.stitchList().stitches


def _get_source(token: Token) -> Source:
    return Source(
        line=token.line,
        column=token.column,
        file=(token.source[1].fileName
              if len(token.source) > 1 and hasattr(token.source[1], "fileName")
              else None)
    )
