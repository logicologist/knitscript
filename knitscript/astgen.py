from functools import singledispatch
from operator import attrgetter
from typing import Collection, Union, Optional

from antlr4 import ParserRuleContext, Token

from knitscript.astnodes import Block, Call, Document, ExpandingStitchRepeat, \
    FixedBlockRepeat, FixedStitchRepeat, Get, NaturalLit, Node, PatternDef, \
    Pattern, Row, RowRepeat, Side, StitchLit, StringLit, Using
from knitscript.parser.KnitScriptParser import KnitScriptParser
from knitscript.stitch import Stitch


@singledispatch
def build_ast(ctx: ParserRuleContext) -> Node:
    """
    Builds an AST from a parse tree generated by ANTLR.

    :param ctx: a parse tree context node
    :return: the AST corresponding to the parse tree
    """
    raise TypeError(f"unsupported parser context {type(ctx).__name__}")


@build_ast.register
def _(document: KnitScriptParser.DocumentContext) -> Node:
    return Document(stmts=list(map(build_ast, document.stmts)),
                    line=document.start.line,
                    column=document.start.column,
                    file=_get_filename(document.start))


@build_ast.register
def _(stmt: KnitScriptParser.StmtContext) -> Node:
    return build_ast(stmt.using() or stmt.patternDef() or stmt.call())


@build_ast.register
def _(using: KnitScriptParser.UsingContext) -> Node:
    return Using(names=list(map(lambda name: name.text, using.names)),
                 module=using.module.text,
                 line=using.start.line,
                 column=using.start.column,
                 file=_get_filename(using.start))


@build_ast.register
def _(pattern: KnitScriptParser.PatternDefContext) -> Node:
    params = (list(map(attrgetter("text"), pattern.paramList().params))
              if pattern.paramList()
              else [])
    return PatternDef(
        name=pattern.ID().getText(),
        pattern=Pattern(rows=list(map(build_ast, pattern.items)),
                        params=params,
                        env=None,
                        consumes=None,
                        produces=None,
                        line=pattern.start.line,
                        column=pattern.start.column,
                        file=_get_filename(pattern.start)),
        line=pattern.start.line,
        column=pattern.start.column,
        file=_get_filename(pattern.start)
    )


@build_ast.register
def _(item: KnitScriptParser.ItemContext) -> Node:
    return build_ast(item.row() or item.block() or item.rowRepeat())


@build_ast.register
def _(block: KnitScriptParser.BlockContext) -> Node:
    return Block(patterns=list(map(build_ast, block.patternList().patterns)),
                 consumes=None,
                 produces=None,
                 line=block.start.line,
                 column=block.start.column,
                 file=_get_filename(block.start))


@build_ast.register
def _(repeat: KnitScriptParser.PatternRepeatContext) -> Node:
    return build_ast(repeat.fixedPatternRepeat() or repeat.call())


@build_ast.register
def _(repeat: KnitScriptParser.FixedPatternRepeatContext) -> Node:
    return FixedBlockRepeat(
        block=Block(
            patterns=(
                [build_ast(repeat.pattern)]
                if repeat.pattern is not None
                else list(map(build_ast, repeat.patternList().patterns))
            ),
            consumes=None,
            produces=None,
            line=repeat.start.line,
            column=repeat.start.column,
            file=_get_filename(repeat.start)
        ),
        times=build_ast(repeat.times),
        consumes=None,
        produces=None,
        line=repeat.start.line,
        column=repeat.start.column,
        file=_get_filename(repeat.start)
    )


@build_ast.register
def _(call: KnitScriptParser.CallContext) -> Node:
    return Call(target=Get(name=call.ID().getText(),
                           line=call.start.line,
                           column=call.start.column,
                           file=_get_filename(call.start)),
                args=list(map(build_ast, call.args) if call.args else []),
                line=call.start.line,
                column=call.start.column,
                file=_get_filename(call.start))


@build_ast.register
def _(repeat: KnitScriptParser.RowRepeatContext) -> Node:
    return RowRepeat(rows=list(map(build_ast, repeat.items)),
                     times=build_ast(repeat.times),
                     consumes=None,
                     produces=None,
                     line=repeat.start.line,
                     column=repeat.start.column,
                     file=_get_filename(repeat.start))


@build_ast.register
def _(row: KnitScriptParser.RowContext) -> Node:
    return Row(
        stitches=list(map(build_ast, (row.stitchList().stitches
                                      if row.stitchList() is not None
                                      else []))),
        side=Side(row.side().getText()) if row.side() is not None else None,
        consumes=None,
        produces=None,
        line=row.start.line,
        column=row.start.column,
        file=_get_filename(row.start)
    )


@build_ast.register
def _(repeat: KnitScriptParser.StitchRepeatContext) -> Node:
    return build_ast(repeat.fixedStitchRepeat() or
                     repeat.expandingStitchRepeat() or
                     repeat.stitch())


@build_ast.register
def _(fixed: KnitScriptParser.FixedStitchRepeatContext) -> Node:
    return FixedStitchRepeat(
        stitches=list(map(build_ast, _get_stitches(fixed))),
        times=build_ast(fixed.times),
        consumes=None,
        produces=None,
        line=fixed.start.line,
        column=fixed.start.column,
        file=_get_filename(fixed.start)
    )


@build_ast.register
def _(expanding: KnitScriptParser.ExpandingStitchRepeatContext) -> Node:
    return ExpandingStitchRepeat(
        stitches=list(map(build_ast, _get_stitches(expanding))),
        to_last=(build_ast(expanding.toLast)
                 if expanding.toLast
                 else NaturalLit.of(0)),
        consumes=None,
        produces=None,
        line=expanding.start.line,
        column=expanding.start.column,
        file=_get_filename(expanding.start)
    )


@build_ast.register
def _(stitch: KnitScriptParser.StitchContext) -> Node:
    value = Stitch.from_symbol(stitch.ID().getText())
    return StitchLit(value=value,
                     consumes=value.consumes,
                     produces=value.produces,
                     line=stitch.start.line,
                     column=stitch.start.column,
                     file=_get_filename(stitch.start))


@build_ast.register
def _(expr: KnitScriptParser.ExprContext) -> Node:
    return build_ast(expr.call() or
                     expr.variable() or
                     expr.natural() or
                     expr.string())


@build_ast.register
def _(variable: KnitScriptParser.VariableContext) -> Node:
    return Get(name=variable.ID().getText(),
               line=variable.start.line,
               column=variable.start.column,
               file=_get_filename(variable.start))


@build_ast.register
def _(natural: KnitScriptParser.NaturalContext) -> Node:
    return NaturalLit(value=int(natural.getText()),
                      line=natural.start.line,
                      column=natural.start.column,
                      file=_get_filename(natural.start))


@build_ast.register
def _(string: KnitScriptParser.StringContext) -> Node:
    return StringLit(value=string.getText()[1:-1],
                     line=string.start.line,
                     column=string.start.column,
                     file=_get_filename(string.start))


def _get_stitches(ctx: Union[KnitScriptParser.FixedStitchRepeatContext,
                             KnitScriptParser.ExpandingStitchRepeatContext]) \
        -> Collection[ParserRuleContext]:
    return [ctx.stitch()] if ctx.stitch() else ctx.stitchList().stitches


def _get_filename(token: Token) -> Optional[str]:
    if len(token.source) >= 2 and hasattr(token.source[1], "fileName"):
        return token.source[1].fileName
    else:
        return None
